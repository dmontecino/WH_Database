<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>groups</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="groups_files/libs/clipboard/clipboard.min.js"></script>
<script src="groups_files/libs/quarto-html/quarto.js"></script>
<script src="groups_files/libs/quarto-html/popper.min.js"></script>
<script src="groups_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="groups_files/libs/quarto-html/anchor.min.js"></script>
<link href="groups_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="groups_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="groups_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="groups_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="groups_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<!-- # Grouping of Locations, Events, and Sources {.unnumbered} -->
<p>Following the standard units in the data model, the simplest data of a Field Visit is an Source Record found in a single Event in a single Location. However, depending on the methodology of a specific Surveillance Activity, Sources Records could be clustered in units that are clustered by Events. In the same manner, Events can be clustered by units that are clustered by Locations, and Locations can be clustered by units that are clustered by Field Visits:</p>
<ul>
<li>Field Activity<sub>w</sub>
<ul>
<li><strong>Cluster unit</strong><sub>ùõº</sub>
<ul>
<li><strong>Cluster unit</strong><sub>ùõΩ</sub>
<ul>
<li>Location<sub>x</sub>
<ul>
<li><strong>Cluster unit</strong><sub>Œ≥</sub>
<ul>
<li><strong>Cluster unit</strong><sub>ùõø</sub>
<ul>
<li>Event<sub>y</sub>
<ul>
<li><strong>Cluster unit</strong><sub>ùúÇ</sub>
<ul>
<li>Source Record<sub>z</sub></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>A second layer of complexity is the addition of clustered units that are not nested. For example, the same structure shown before plus the cluster of Source Records per season of the year:</p>
<ul>
<li>Field Activity<sub>w</sub>
<ul>
<li><strong>Spatial Cluster unit</strong><sub>ùõº</sub>
<ul>
<li><strong>Spatial Cluster unit</strong><sub>ùõΩ</sub>
<ul>
<li>Location<sub>x</sub>
<ul>
<li><strong>Spatial Cluster unit</strong><sub>Œ≥</sub>
<ul>
<li><strong>Spatial Cluster unit</strong><sub>ùõø</sub>
<ul>
<li>Event<sub>y</sub>
<ul>
<li><strong>Spatial Cluster unit</strong><sub>ùúÇ</sub></li>
<li><strong>Temporal Cluster unit</strong><sub>–¥</sub>
<ul>
<li>Source Record<sub>z</sub></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p>The data model considers the possibility to include clustering levels between the Source Record and Event, Event and Location, and Location and Field Visit. The data model also allows the inclusion of non-nested clustering units. Unavoidably, how many clustering levels are considered, what each of these clustering units represent, what are they clustering, and the data to be collected from each of these extra units will vary among Surveillance Activities. Therefore, clustering levels and their meaning must be reported in the Surveillance Activity metadata and the only properties for each level are the identifier, the cross identifier, the origin of the cross identifier, and a description.</p>
<p>For example, the units Location, Event, and Source Record could be enough to record the data structure of a specific Surveillance Activity gathering information from Protected Areas (Locations) at points (Events) where dead animals (Source Records) are found any given time. However, another Surveillance Activity could have the following structure: protected area, zones within protected area (Location), grid cells within each zone, capture site with a pair of mist nests within each grid cell (Event), mist nets of the capture site, and bats captured (Source Records) per season.</p>
<!-- Further characteristics of each clustering unit, whether static or time dependent through the Surveillance Activity period, should be prepared in a file, such as an excel sheet, with columns with the identifiers of all relevant units (Location grouping units. Event grouping units that are not the Location, and Source Record grouping units that are not the Event) and  attached it at the corresponding level. A recommendation is to prepared a sheet for the features of all spatio temporal grouping units visited during a Field Visit and attach it at this level (Field Visit). The columns with the identifiers will allow joining the data of the corresponding Field Visit (Locations, Events, Source Records, grouping units) with the attached and spatial data. -->
<section id="final-comment-on-sources-and-source-records" class="level2">
<h2 class="anchored" data-anchor-id="final-comment-on-sources-and-source-records">Final Comment on Sources and Source Records</h2>
<p>Users can group Source Records from different Sources beyond the Incident they belong to. For example, a Surveillance Objective involves sampling animals and cages in a market as part of targeted surveillance efforts. One of the potential options to structure these data is to set the market as the Location and set each vendor within the market as an ‚ÄòIncident‚Äô. Let‚Äôs pretend that in one of the Incidents (a vendor), a sample of feces is collected from the bottom of a cage, the cage has three animals of the same species, and only one of those animals is sampled (one oral swab sample).</p>
<p>Under this scenario, the cage is providing three Source Records. Firstly, an Environmental Source with a single Environmental Source Record containing the feces sampled from the bottom of the cage. Secondly, an Observation with the two animals in the cage that are only observed (Observations always have a single Record). And thirdly, an Animal Source with a single Animal Source Record containing the oral swab.</p>
<p>How to track that these Source Records belong to the same cage? The database provides tags per user request that allow to label Sources Records that belong to units lower than Incidents and keep them linked. In the example, the three Source Records can receive the same tag (‚Äúcage1‚Äù) in order to track that they have a more specific origin than Incident.</p>
<p>An Animal Source Record has data of a single animal always, which might or might not be identified individually and tracked over time.</p>
<p>Environmental and</p>
<p>In te case of env and arthropod sources, they could be equivalent to the location.</p>
<p>Incidents can include Observations (species) with healthy animals only, as long as they are part of a wildlife health event.</p>
<p>Each Observation generates one and only one Source Record with immutable data. In that unique Source Record animals are categorized by sex, age, and health status. The captivity categories of the corresponding animals; their anomalies; and potential causes of injury, disease, or dead can be provided.</p>
<p>Add which are the locations Add each Location grouping sites ADd number of field visit to each Location frequency of visits to each Location what, where, when, how, who, why in the surveillace metadata</p>
<p>these assign each Location to a zone within protected area, use an extra unit to group each Location (zone) to the corresponding Protected Area. Events within a Location (zone) can be group by a grid cell and an extra unit will be needed to represent the to group corresponds to a market and the Event corresponds to a cage, then it is possible to assign the units between these levels: the corresponding stall and vendor to each Event. See moree details</p>
</section>
<section id="event-grouping" class="level2">
<h2 class="anchored" data-anchor-id="event-grouping">Event Grouping</h2>
<p>Events can be grouped in higher groups if needed (see ‚ÄòGrouping of Events‚Äô below). For example, each cage with sampled animals can be an Event and each Event can grouped by stall and vendor. If each stall is an Event, then the sampled individuals (Sampled Source) can be grouped by cage below the Event and the Event itself (see ‚ÄòGrouping of Source Records‚Äô in the ‚ÄòSource Records‚Äô section below).</p>
<p>Group units only have the Identifier as as attribute. Other attributes are not considered because it is not possible to guess whet properties are of interest for different surveillance initiatives. Therefore, properties of Groups should be attached as a file containing that information. The type and Identifier of each Group should be provided in order to join the Group information entered in the database and the Group data. We strongly recommend to attach a spatial file and report its projection in the Surveillance Activity metadata.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>