<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>specimen</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="specimen_files/libs/clipboard/clipboard.min.js"></script>
<script src="specimen_files/libs/quarto-html/quarto.js"></script>
<script src="specimen_files/libs/quarto-html/popper.min.js"></script>
<script src="specimen_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="specimen_files/libs/quarto-html/anchor.min.js"></script>
<link href="specimen_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="specimen_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="specimen_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="specimen_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="specimen_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<!-- # Specimens {.unnumbered} -->
<p>Specimens refer to the materials collected from Sources at time <strong>t</strong> (from Source Records) for the purpose of conducting Diagnostics to identify hazards (biological, chemical, physical) or physiological problems. Specimens can range from the entire body of a living animal to conduct an ultrasound to a minimal amount of fluid (e.g., blood) to perform advanced assays. An example of Group Source Specimen is feces collected from a cage holding animals of the same species. An example of Animal Source Specimen is a rectal swab. An example of Environmental Source Specimen is 10 grams of soil. An example of Arthropod Source Specimen is a pool of mosquitoes of the same species.</p>
<p>Furthermore, a Specimen can be composed of urine of an animal (Animal Source Specimen) mixed with water from a pond (Environmental Source Specimen) next to the Animal Source. Therefore <strong>Specimens can originate from many Sources and from Sources of different types</strong>.</p>
<p>Specimens are characterized by an identifier, the type of material (water, hair, kidney, animal), the original amount collected (e.g., ‘full animal’ or 0.35 mm), the current amount, among others. Additionally, the data model can hold data on the storage location of Specimens (building, laboratory name, refrigerator name, etc.), their availability, ownership, current amount, and exportation processes (See Data Dictionary).</p>
<p>Specimens without any amount left can be included in the data model so the last storage, exportation processes, and its use in Diagnostic procedures can be tracked.</p>
<section id="group-source-record-specimens" class="level3">
<h3 class="anchored" data-anchor-id="group-source-record-specimens">Group Source Record Specimens</h3>
</section>
<section id="speiemens-pueden-vennir-desde-multiple-group-source-records-e-differentes-tipos." class="level1">
<h1>speiemens pueden vennir desde multiple Group source records e differentes tipos.</h1>
<p>Group Sources can provide Specimens at time <strong>t</strong> (see “Specimens”). Information on the specific animal providing the Specimens, if it is available, will be lost. An example are feces collected from the bottom of a cage with animals of the same species but it is unknown which of the animals dropped the feces. However, there is information of the species of the animals and the observed health status of animals, including the unknown individual that dropped them. Sex and age of the animals could be known too. If Specimens can be traced to a single animal, it is recommended to associated them to an Animal Source (see below).</p>
<p>The last date a Group Source was observed is not necessarily the last time the Group Source can provide Specimens. For example, it is possible to collect feces from an empty cage that a Group Source was using until two days ago. The age, sex, and health status distribution of the Group Source Record could be all unknown.</p>
<section id="animal-source-specimens" class="level3">
<h3 class="anchored" data-anchor-id="animal-source-specimens">Animal Source Specimens</h3>
<p>For Animal Specimens that are equivalent to the Animal Source Record (both representing the ‘full animal’), information should be provided at both the Source Record and Specimen levels. The Source Record and Specimen can have the same identifier or different identifiers, and the amount of the Specimen in such cases should be indicated as ‘full animal’.</p>
<p>Animal Sources can provide Specimens at time <strong>t</strong> (see “Specimens”) and they should be traceable at the individual level. An example are feces collected from the bottom of a cage with animals of the same species, and it was observed which animal dropped them. If Specimens cannot be traced to a single animal but to a group of them, the Specimens should be associated with a Group Source (see above).</p>
<p>The date of death of an Animal Source Record is not necessarily the last time it can provide Specimens because it is possible to collect them from the carcass (dead Animal Source).</p>
</section>
<section id="env-source-specimens" class="level3">
<h3 class="anchored" data-anchor-id="env-source-specimens">Env Source Specimens</h3>
<p>Setting the Environmental Source type determines the Specimen type provided for those Sources (see ‘Specimens’ below). For example, feces can only yield feces as Specimens, and water in a pond can only provide water.</p>
</section>
<section id="inv-source-specimens" class="level3">
<h3 class="anchored" data-anchor-id="inv-source-specimens">Inv source specimens</h3>
<p>Invertebrate Source Records may include multiple species; however, it is expected that the Specimens associated with these Records only contain invertebrates of the same species.</p>
</section>
<section id="pooled-specimens" class="level3">
<h3 class="anchored" data-anchor-id="pooled-specimens">Pooled Specimens</h3>
<p>In the data model, a Pooled Specimen is the mix of two or more Specimens and its origin is not a Source but another Specimen.</p>
</section>
<section id="specimens-in-containers" class="level3">
<h3 class="anchored" data-anchor-id="specimens-in-containers">Specimens in Containers</h3>
<p>In situations where space or materials are limited, it is possible that multiple Specimens are stored in the same container. This approach is not ideal because it can lead to cross-contamination and make actual Specimen tracing more complex. To address the tracing of these Specimens, a unique container identifier, such as a jar identifier, can be added in the database. Specimens sharing the same container will have the same container identifier. Although individual Specimens within the same container may not be labeled individually, each Specimen should be given a unique Specimen Code in the database. This Code can be the same as the container identifier, followed by the “organ name” or a numeric string (e.g., “.1”, “.2”, etc.). Specific details for each individual Specimen within the container, such as type, quantity, etc, should allow their visual identification within the container.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>